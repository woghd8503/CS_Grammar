using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;


namespace Test1
{
    class MainApp
    {
        // Q1. 클래스와 객체, 인스턴스는 서로 어떤 점이 다른가요?

        // A1. 클래스는 OOP Object-Oriented Programming의 핵심이다. 왜냐하면 OOP의 핵심은 사람이 실제세계에서 사물을 바라보는 것처럼, 
        // 직관적인 프로그래밍이 가능하도록 하는 것인데, 클래스가 이 사물의 도면에 해당하기 때문이다. 예를 들어 어떤 사물이 존재한다면,
        // 그 사물에 대한 설계도난 도면 또한 동시에 존재할 확률이 높다. 이러한 개채(=인스턴스, 사물)의 도면역할을 한다. 책에서는 클래스를 
        // 개체를 만들기 위한 청사진으로 정의하였다.

        // 즉, 개체(인스턴스)는 프로그램 내에 실존하는 것이며, 클래스는 이를 실체화하기 위한 도면이다.

        // A1. 이 문제의 의도는 부모 클래스와 자식 클래스 사이의 형식 변환에 대해 이해하고 있는가이다.

        // Q2. 다음 코드에서 오류를 찾고, 오류의 원인을 설명하세요.

        // A2. B d = new A(); 가 잘못되었다. 
        // C#에서는 암시적으로 자식 클래스의 형식을 통해 부모 클래스를 개체화하는 것이 불가능하다. 참고로 책에서는
        // 이를 캐스팅이라는 단어로 통일하였지만, 다운 캐스팅 (Down Casting)이라는 프로그래밍 단어가 존재한다. 따라서 해당하는
        // 구문은 컴파일오류가 발생한다. 이를 고치기 위해서는 암시적으로 개체화시키는 것이 아니라, 명시적인 캐스팅을 통해 개체화해야한다.

        // Q3. this키워드와 base 키워드에 대해 설명하세요.

        // A3. this 키워드는 실체화된 자기 자신을 가리키는 것이다. base 키워드는 자신이 상속받고 있는 부모 클래스를 가리키는 것이다.

        // Q4. 구조체에 대한 다음 설명 중 틀린 것을 모두 찾으세요.
        //    1. struct 키워드를 이용하여 선언한다.
        //    2. 복사할 때 얕은 복사가 이루어진다.
        //    3. 참조 형식이다.
        //    4. 메소드를 가질 수 있다.

        // A4. 2, 3번이 틀렸다.
        // 구조체는 값 형식을 복합 데이터 형식이며, 어떤 구조체를 선언하거나 정의하거나 스택 메모리에 어떤 구조체에 대한 정보를 담고 있는 데이터가
        // 할당되는 것을 알 수 있다. 이를 근거로 우리는 구조체에서 깊은 복사가 일어남을 추론할 수 있다. 얕은 복사는 힙 메모리에 할당한 어떤 데이터를 
        // 스택 메모리 내 2개 이상의 메모리가 참조하면서 발생한다. 하지만 구조체의 경우 값 형식이 때문에, 애초에 데이터가 힙 메모리가 아닌 스택 메모리에
        // 할당된다. 따라서 복사를 진행할 때, 깊은 복사가 일어날 수 밖에 없는 구조인 것을 우리는 알 수 있다.



    }

    // Q5. 다음 코드를 컴파일 및 실행이 가능하도록 수정하세요.


}

